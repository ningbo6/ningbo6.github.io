<!DOCTYPE html>
<html>
<head>
<title>原-关于瑞典轮机器人——youbot的讨论.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<p>（转载请注明作者和出处：https://ningbo6.github.io）
一个老外给出了一个观点：把他当做平面移动处理，比较贴合我的想法，整体的运动与轮无关，这样复杂的问题简单化。</p>
<p>他的原话：</p>
<p>Just a thought, for this robot it may be easier to model the motion of the entire robot instead of modeling the individual wheel. One path could be to use a plugin that accepts twist messages and applies them to the robot base. An example of this is the Planar Move Plugin.</p>
<p>In two dimension (i.e. stage) this might have been called the holonomic plugin.</p>
<p>网址为：</p>
<p><a href="http://answers.gazebosim.org/question/4078/how-to-simulate-a-mecanum-wheel-in-gazebo/">How to simulate a mecanum wheel in Gazebo</a></p>
<hr>
<p>也有人提出这样的观点：通过添加一个转动关节轴进行角度改变来模拟瑞典轮</p>
<p>原话如下：</p>
<p>new to all this but thought I could simulate a mecanum wheel by adding a rotational joint about z-axis for each wheel that is restricted to 0, 45 and 90 degrees. this way the base can go forward/backward/45 degree forward/backward and left/right, sideway left/right and rotate left/right. the simulated moves would need to translate into rotational direction sets for the physical movements of the 4 wheel motors? however - how can I have a restricted set of angels for a joint and what needs to be in place to translate it into the physical wheel rotation command? of course the simulation would only provide a logical wheel view and it will also need a special collision handling as the wheels do not really rotate on the z-axis. but in total an easy representation of the possible moves?</p>
<p>网址如下：</p>
<p><a href="http://answers.gazebosim.org/question/7084/mecanum-wheels-ok-in-one-direction-not-the-other-in-gazebo/">Mecanum wheels ok in one direction not the other in Gazebo</a></p>
<hr>
<p>还有一个人提出消除掉轮与地面之间的摩擦，然后按照twist来结算每个轮的速度，只是让轮旋转，机器人的移动依赖于twist。而不依赖于每个轮的旋转。我觉得这个思路很好。</p>
<p>原话：</p>
<blockquote>
<p>It’s a really interesting simulation issue.</p>
</blockquote>
<p>First of all, let’s a look at the wheels. They are not standard wheels, they are mecanum wheels. This kind of wheels help the robot to move and rotate easily in any directions, even in congested area. The movement come from the resulting rotation speeds of the wheels, which are independent. I have found I nice explanation of the relationship between the wheels rotation and the resulting movement on this lego page. On the videos, the youBot looks like gliding on the ground.</p>
<p>From a design point of view, this is convenient, because it is similar to a planar joint + a revolute joint between the base and the ground. Very easy to control.</p>
<p>From a simulation point of view, it is a nightmare.</p>
<p>I doubt that the repo from youBot or WPI-RAIL did the job, because they involve casters. And there is no casters on the real KUKA youBot. If you have a look at their teleop program, you will see that this program align the wheels before the rotation, which is not the design of a mecanum wheel at all. With the mesh of the wheels, you will see it. This not natural (this is also why the wheels solid shape is a sphere). And even worst, the the rotation is therefore not supported. So for me, this model is really poor.</p>
<p>I raised the question on Gazebo answers. Someone suggested to use this planar controller. I considered it as a second choice, but finally, this is very close to the behavior of the real mecanum wheels, as you define the x/y velocity and rotation, which can be directly linked to the wheel individual speeds. I have remove the friction between the wheels and the ground.</p>
<p>On the real robot, this x/y speed and rotation translation to individual wheels speeds would also be very convenient.</p>
<p>A visually better solution would be to add the mesh of the wheels, and rotate them according to the planar messages. No time to work on this.</p>
<p>Finally, if you are looking for a very physical solution, I have found this link, where it has been done in another simulator, by mixing kinematics and dynamics solutions.</p>
<p>That would be really great to have more realistic solution. For my requirement, the planar controller is enough.</p>
<p>网址：</p>
<p><a href="https://github.com/micpalmia/youbot_ros_tools/issues/5">Move the youbot using its wheels</a></p>

</body>
</html>
